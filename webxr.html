<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>å²­å—ä¹å™¨WebXRå¢å¼ºç°å®ä½“éªŒ</title>
    
    <!-- Three.jsæ ¸å¿ƒåº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="./js/GLTFLoader.js"></script>
    <script src="./js/DRACOLoader.js"></script>
    
    <!-- äºŒç»´ç æ£€æµ‹åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsqr/1.4.0/jsQR.min.js"></script>
    
    <style>
        body {
            margin: 0;
            background: #000;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #startContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00ff00;
        }
        
        #startWebXR {
            padding: 20px 40px;
            font-size: 18px;
            background: linear-gradient(45deg, #007BFF, #0056b3);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 4px 15px rgba(0,123,255,0.3);
            transition: all 0.3s ease;
        }
        
        #startWebXR:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,123,255,0.4);
        }
        
        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            z-index: 100;
            display: none;
            border: 1px solid #00ff00;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            display: none;
            border: 1px solid #007BFF;
        }
        
        #debugInfo {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 100;
            display: none;
            max-height: 200px;
            overflow-y: auto;
            min-width: 200px;
            border: 1px solid #ffc107;
        }
        
        .btn {
            padding: 10px 20px;
            margin: 5px;
            background: #007BFF;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            background: #0056b3;
            transform: translateY(-1px);
        }
        
        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }
        
        #qrCanvas {
            display: none;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-ready { background: #28a745; }
        .status-scanning { background: #ffc107; animation: pulse 1s infinite; }
        .status-detected { background: #007BFF; }
        .status-error { background: #dc3545; }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .detection-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 3px solid #00ff00;
            border-radius: 20px;
            z-index: 50;
            display: none;
            animation: scanAnimation 2s infinite;
        }
        
        @keyframes scanAnimation {
            0%, 100% { border-color: #00ff00; }
            50% { border-color: #ffff00; }
        }
        
        .detection-overlay::before {
            content: 'å°†äºŒç»´ç æ”¾åœ¨æ¡†å†…\Aæˆ–æŒ‰æ‰‹æŸ„è§¦å‘å™¨æµ‹è¯•';
            position: absolute;
            top: -50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: #00ff00;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            white-space: pre;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="startContainer">
        <h2>ğŸµ å²­å—ä¹å™¨WebXRä½“éªŒ</h2>
        <p>ä½¿ç”¨VRå¤´æ˜¾è¿›å…¥å¢å¼ºç°å®ä¹å™¨ä¸–ç•Œ</p>
        <button id="startWebXR">å¯åŠ¨WebXR ARä½“éªŒ</button>
        <p><small>
            âœ… æ”¯æŒMeta Quest 3/3S<br>
            âœ… å½©è‰²æ‘„åƒå¤´é€è§†<br>
            âœ… æ‰‹æŸ„/æ‰‹åŠ¿äº¤äº’<br>
            âœ… <strong>Raw Camera Access API</strong>ï¼ˆå¯é€‰ï¼‰<br>
            <br>
            <strong>ğŸ’¡ ä¼˜åŒ–è®¾ç½®ï¼ˆå¯é€‰ï¼‰ï¼š</strong><br>
            1. åœ¨Questæµè§ˆå™¨è¾“å…¥ <code>chrome://flags</code><br>
            2. æœç´¢å¹¶å¼€å¯ï¼š<br>
            &nbsp;&nbsp;&nbsp;"<strong>Experimental Web Platform Features</strong>"<br>
            3. <strong>é‡å¯æµè§ˆå™¨</strong><br>
            <small>ï¼ˆå³ä½¿ä¸å¼€å¯ä¹Ÿèƒ½æ­£å¸¸ä½¿ç”¨æ‰‹æŸ„äº¤äº’ï¼‰</small>
        </small></p>
    </div>
    
    <div id="info">
        <div><span class="status-indicator status-ready"></span>çŠ¶æ€: <span id="status">å‡†å¤‡å°±ç»ª</span></div>
        <div>æ£€æµ‹åˆ°: <span id="qrResult">æ— </span></div>
        <div>å½“å‰ä¹å™¨: <span id="currentInstrument">æ— </span></div>
        <div id="instructionText">
            <strong>ğŸ® ä½¿ç”¨æ–¹æ³•ï¼š</strong><br>
            1. æŒ‰æ‰‹æŸ„è§¦å‘å™¨å¾ªç¯æµ‹è¯•ä¹å™¨<br>
            2. æˆ–å°è¯•å°†äºŒç»´ç ç½®äºè§†é‡ä¸­å¿ƒ<br>
            <small>âš ï¸ æ³¨æ„ï¼šQuestç›®å‰é™åˆ¶æ‘„åƒå¤´è®¿é—®</small>
        </div>
    </div>
    
    <div id="controls">
        <button id="playButton" class="btn" disabled>æ’­æ”¾éŸ³ä¹</button>
        <button id="exitWebXR" class="btn">é€€å‡ºAR</button>
        <div style="margin-top: 10px;">
            <span id="audioInfo">æ— éŸ³é¢‘</span>
        </div>
    </div>
    
    <div id="debugInfo">
        <div><strong>è°ƒè¯•ä¿¡æ¯:</strong></div>
        <div id="debugText"></div>
    </div>
    
    <div class="detection-overlay" id="detectionOverlay"></div>
    <canvas id="qrCanvas"></canvas>

    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer;
        let xrSession = null;
        let xrReferenceSpace = null;
        let isWebXRActive = false;
        let currentXRFrame = null; // æ·»åŠ å½“å‰å¸§å¼•ç”¨
        
        // ä¹å™¨é…ç½®
        const instrumentConfigs = {
            'pattern1': {
                model: 'model1.gltf',
                audio: 'audio1.mp3',
                info: 'info1.txt',
                scale: [0.02, 0.02, 0.02],
                name: 'çµç¶'
            },
            'pattern2': {
                model: 'model2.gltf', 
                audio: 'audio2.mp3',
                info: 'info2.txt',
                scale: [0.03, 0.03, 0.03],
                name: 'è‘«èŠ¦ä¸'
            }
        };
        
        // åº”ç”¨çŠ¶æ€
        let currentInstrument = null;
        let activeModel = null;
        let audioManager = null;
        let qrDetector = null;
        let modelLoader = null;
        let controllers = [];
        
        // åˆå§‹åŒ–åº”ç”¨
        class WebXRInstrumentApp {
            constructor() {
                this.init();
            }
            
            async init() {
                console.log('åˆå§‹åŒ–WebXRä¹å™¨åº”ç”¨...');
                
                // æ£€æŸ¥WebXRæ”¯æŒ
                if (!navigator.xr) {
                    this.showError('æ­¤è®¾å¤‡ä¸æ”¯æŒWebXR API');
                    return;
                }
                
                // æ£€æŸ¥ARæ”¯æŒ
                const arSupported = await navigator.xr.isSessionSupported('immersive-ar');
                if (!arSupported) {
                    this.showError('æ­¤è®¾å¤‡ä¸æ”¯æŒWebXR ARæ¨¡å¼\nè¯·ç¡®ä¿ï¼š\n1. ä½¿ç”¨Quest 3/3Sæˆ–å…¼å®¹è®¾å¤‡\n2. æµè§ˆå™¨å·²å¼€å¯WebXRå®éªŒç‰¹æ€§');
                    return;
                }
                
                // æ£€æŸ¥å¯é€‰ç‰¹æ€§æ”¯æŒ
                try {
                    const localFloorSupported = await navigator.xr.isSessionSupported('immersive-ar', {
                        optionalFeatures: ['local-floor']
                    });
                    this.updateDebugInfo(`local-flooræ”¯æŒ: ${localFloorSupported ? 'æ˜¯' : 'å¦'}`);
                } catch (e) {
                    this.updateDebugInfo('æ— æ³•æ£€æŸ¥local-flooræ”¯æŒ');
                }
                
                // åˆå§‹åŒ–Three.js
                this.setupThreeJS();
                
                // åˆå§‹åŒ–æ¨¡å‹åŠ è½½å™¨
                this.initModelLoader();
                
                // åˆå§‹åŒ–éŸ³é¢‘ç®¡ç†å™¨
                this.audioManager = new AudioManager();
                await this.audioManager.preloadAudio(instrumentConfigs);
                
                // åˆå§‹åŒ–äºŒç»´ç æ£€æµ‹å™¨
                this.qrDetector = new QRDetector();
                
                // è®¾ç½®UIäº‹ä»¶
                this.setupUI();
                
                this.updateDebugInfo('åº”ç”¨åˆå§‹åŒ–å®Œæˆ');
                console.log('WebXRä¹å™¨åº”ç”¨åˆå§‹åŒ–å®Œæˆ');
            }
            
            setupThreeJS() {
                // åˆ›å»ºåœºæ™¯
                scene = new THREE.Scene();
                
                // åˆ›å»ºç›¸æœº
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 1.6, 3);
                
                // åˆ›å»ºæ¸²æŸ“å™¨ - Questä¼˜åŒ–è®¾ç½®
                renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true, // å…³é”®ï¼šå¯ç”¨é€æ˜èƒŒæ™¯ç”¨äºARé€è§†
                    powerPreference: 'high-performance', // Questæ€§èƒ½ä¼˜åŒ–
                    stencil: false // Questæ€§èƒ½ä¼˜åŒ–
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // å¯ç”¨WebXR
                renderer.xr.enabled = true;
                
                document.body.appendChild(renderer.domElement);
                
                // æ·»åŠ å…‰ç…§
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                // å¯åŠ¨æ¸²æŸ“å¾ªç¯
                renderer.setAnimationLoop((timestamp, frame) => {
                    currentXRFrame = frame; // ä¿å­˜å½“å‰XRå¸§
                    this.render();
                });
                
                console.log('Three.jsè®¾ç½®å®Œæˆ');
            }
            
            initModelLoader() {
                if (typeof THREE.GLTFLoader === 'function') {
                    modelLoader = new THREE.GLTFLoader();
                    
                    if (typeof THREE.DRACOLoader === 'function') {
                        const dracoLoader = new THREE.DRACOLoader();
                        dracoLoader.setDecoderPath('./js/draco/');
                        dracoLoader.preload();
                        modelLoader.setDRACOLoader(dracoLoader);
                        this.updateDebugInfo('GLTFLoader + DRACOLoader å·²å°±ç»ª');
                    } else {
                        this.updateDebugInfo('GLTFLoader å·²å°±ç»ªï¼ˆæ— Dracoæ”¯æŒï¼‰');
                    }
                } else {
                    this.updateDebugInfo('GLTFLoader æœªæ‰¾åˆ°ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶');
                }
            }
            
            setupUI() {
                document.getElementById('startWebXR').addEventListener('click', () => {
                    this.startWebXR();
                });
                
                document.getElementById('playButton').addEventListener('click', () => {
                    this.toggleAudio();
                });
                
                document.getElementById('exitWebXR').addEventListener('click', () => {
                    this.exitWebXR();
                });
            }
            
            async startWebXR() {
                try {
                    this.updateStatus('å¯åŠ¨WebXR...');
                    this.updateDebugInfo('è¯·æ±‚WebXR ARä¼šè¯...');
                    
                    // è¯·æ±‚WebXR ARä¼šè¯ - æ‘„åƒå¤´è®¿é—®ä½œä¸ºå¯é€‰ç‰¹æ€§
                    xrSession = await navigator.xr.requestSession('immersive-ar', {
                        optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking', 'camera-access'] // camera-accessæ”¹ä¸ºå¯é€‰
                    });
                    
                    // è®¾ç½®æ¸²æŸ“å™¨ - ç¡®ä¿å…¼å®¹æ€§
                    await renderer.xr.setSession(xrSession);
                    
                    // å°è¯•åˆ›å»ºWebGLç»‘å®šç”¨äºæ‘„åƒå¤´è®¿é—®ï¼ˆå¯é€‰ï¼‰
                    const gl = renderer.getContext();
                    let cameraAccessAvailable = false;
                    
                    try {
                        if (typeof XRWebGLBinding !== 'undefined') {
                            this.xrWebGLBinding = new XRWebGLBinding(xrSession, gl);
                            cameraAccessAvailable = true;
                            this.updateDebugInfo('âœ… XRWebGLBindingå·²åˆ›å»º');
                            this.updateDebugInfo('ğŸ¥ Raw Camera Accesså¯ç”¨');
                        } else {
                            this.updateDebugInfo('âš ï¸ XRWebGLBindingä¸å¯ç”¨');
                            this.updateDebugInfo('   ä½¿ç”¨å¤‡ç”¨äº¤äº’æ–¹å¼');
                        }
                    } catch (bindingError) {
                        console.log('XRWebGLBindingåˆ›å»ºå¤±è´¥:', bindingError);
                        this.updateDebugInfo('âš ï¸ æ‘„åƒå¤´ç»‘å®šå¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹å¼');
                        cameraAccessAvailable = false;
                    }
                    
                    // ç­‰å¾…ä¼šè¯å®Œå…¨åˆå§‹åŒ–
                    await new Promise(resolve => {
                        xrSession.addEventListener('end', () => {
                            this.onSessionEnd();
                        });
                        // ç»™ä¼šè¯ä¸€äº›æ—¶é—´æ¥å®Œå…¨åˆå§‹åŒ–
                        setTimeout(resolve, 100);
                    });
                    
                    // è·å–å‚è€ƒç©ºé—´ - å°è¯•å¤šç§ç±»å‹ä»¥ç¡®ä¿å…¼å®¹æ€§
                    try {
                        xrReferenceSpace = await xrSession.requestReferenceSpace('local-floor');
                        this.updateDebugInfo('ä½¿ç”¨local-floorå‚è€ƒç©ºé—´');
                    } catch (e) {
                        try {
                            xrReferenceSpace = await xrSession.requestReferenceSpace('local');
                            this.updateDebugInfo('é™çº§åˆ°localå‚è€ƒç©ºé—´');
                        } catch (e2) {
                            try {
                                xrReferenceSpace = await xrSession.requestReferenceSpace('viewer');
                                this.updateDebugInfo('é™çº§åˆ°viewerå‚è€ƒç©ºé—´');
                            } catch (e3) {
                                throw new Error('æ— æ³•è·å–ä»»ä½•æ”¯æŒçš„å‚è€ƒç©ºé—´ç±»å‹');
                            }
                        }
                    }
                    
                    // è®¾ç½®æ§åˆ¶å™¨
                    this.setupControllers();
                    
                    // å¯åŠ¨äºŒç»´ç æ£€æµ‹ï¼ˆæ ¹æ®å¯ç”¨æ€§é€‰æ‹©æ–¹å¼ï¼‰
                    if (cameraAccessAvailable && this.xrWebGLBinding) {
                        this.qrDetector.startWebXRDetection((qrData) => {
                            this.handleQRDetection(qrData);
                        }, gl, this.xrWebGLBinding);
                        this.updateDebugInfo('ğŸ“¸ Raw Camera Accessæ£€æµ‹å·²å¯åŠ¨');
                    } else {
                        // å›é€€åˆ°åŸºç¡€æ£€æµ‹æ–¹å¼
                        this.qrDetector.startBasicDetection((qrData) => {
                            this.handleQRDetection(qrData);
                        });
                        this.updateDebugInfo('ğŸ“± åŸºç¡€æ£€æµ‹æ¨¡å¼å·²å¯åŠ¨');
                    }
                    
                    // æ›´æ–°UI
                    this.showWebXRUI();
                    
                    isWebXRActive = true;
                    this.updateStatus('WebXRè¿è¡Œä¸­');
                    this.updateDebugInfo('âœ… WebXR ARä¼šè¯å·²å¯åŠ¨');
                    this.updateDebugInfo('');
                    
                    if (cameraAccessAvailable && this.xrWebGLBinding) {
                        this.updateDebugInfo('ğŸ“¸ Raw Camera Accesså·²å¯ç”¨');
                        this.updateDebugInfo('ğŸ® å¿«é€Ÿæµ‹è¯•ï¼šæŒ‰æ‰‹æŸ„è§¦å‘å™¨');
                        this.updateDebugInfo('ğŸ“± æ‘„åƒå¤´äºŒç»´ç æ£€æµ‹ï¼šå®æ—¶ç›‘å¬ä¸­');
                        this.updateDebugInfo('');
                        this.updateDebugInfo('ğŸ’¡ å°†äºŒç»´ç ç½®äºæ‘„åƒå¤´è§†é‡ä¸­');
                        this.updateDebugInfo('   æˆ–ä½¿ç”¨æ‰‹æŸ„è¿›è¡Œäº¤äº’');
                    } else {
                        this.updateDebugInfo('ğŸ® æ‰‹æŸ„äº¤äº’æ¨¡å¼');
                        this.updateDebugInfo('ğŸ“± æ‘„åƒå¤´è®¿é—®ä¸å¯ç”¨ï¼ˆæ­£å¸¸æƒ…å†µï¼‰');
                        this.updateDebugInfo('');
                        this.updateDebugInfo('ğŸ’¡ æŒ‰æ‰‹æŸ„è§¦å‘å™¨å¾ªç¯åˆ‡æ¢ä¹å™¨');
                        this.updateDebugInfo('   è¿™æ˜¯ä¸»è¦çš„äº¤äº’æ–¹å¼');
                    }
                    
                    console.log('WebXRå¯åŠ¨æˆåŠŸ - Camera Access:', cameraAccessAvailable);
                    
                } catch (error) {
                    console.error('WebXRå¯åŠ¨å¤±è´¥:', error);
                    
                    let errorMessage = 'WebXRå¯åŠ¨å¤±è´¥: ';
                    if (error.message.includes('camera-access') || error.message.includes('not supported')) {
                        // å¦‚æœæ˜¯æ‘„åƒå¤´è®¿é—®é—®é¢˜ï¼Œå°è¯•ä¸å¸¦æ‘„åƒå¤´ç‰¹æ€§é‡æ–°å¯åŠ¨
                        this.updateDebugInfo('âš ï¸ æ‘„åƒå¤´è®¿é—®è¢«æ‹’ç»ï¼Œå°è¯•åŸºç¡€æ¨¡å¼...');
                        try {
                            xrSession = await navigator.xr.requestSession('immersive-ar', {
                                optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking']
                            });
                            
                            // é‡æ–°æ‰§è¡ŒåŸºç¡€åˆå§‹åŒ–
                            await renderer.xr.setSession(xrSession);
                            
                            // åŸºç¡€å‚è€ƒç©ºé—´è®¾ç½®
                            try {
                                xrReferenceSpace = await xrSession.requestReferenceSpace('local-floor');
                            } catch (e) {
                                xrReferenceSpace = await xrSession.requestReferenceSpace('local');
                            }
                            
                            this.setupControllers();
                            this.qrDetector.startBasicDetection((qrData) => {
                                this.handleQRDetection(qrData);
                            });
                            
                            this.showWebXRUI();
                            isWebXRActive = true;
                            this.updateStatus('WebXRè¿è¡Œä¸­ï¼ˆåŸºç¡€æ¨¡å¼ï¼‰');
                            this.updateDebugInfo('âœ… WebXRåŸºç¡€æ¨¡å¼å¯åŠ¨æˆåŠŸ');
                            this.updateDebugInfo('ğŸ® ä½¿ç”¨æ‰‹æŸ„è¿›è¡Œäº¤äº’');
                            return; // æˆåŠŸæ¢å¤ï¼Œé€€å‡ºé”™è¯¯å¤„ç†
                            
                        } catch (fallbackError) {
                            errorMessage += 'åŸºç¡€æ¨¡å¼ä¹Ÿå¤±è´¥\nè¯·æ£€æŸ¥è®¾å¤‡å…¼å®¹æ€§';
                        }
                    } else if (error.message.includes('requestReferenceSpace')) {
                        errorMessage += 'å‚è€ƒç©ºé—´ä¸æ”¯æŒ\nè¯·æ£€æŸ¥Questè®¾å¤‡è®¾ç½®';
                    } else if (error.message.includes('requestSession')) {
                        errorMessage += 'æ— æ³•åˆ›å»ºARä¼šè¯\nè¯·ç¡®ä¿è®¾å¤‡æ”¯æŒå¹¶å·²å¼€å¯ARæ¨¡å¼';
                    } else {
                        errorMessage += error.message;
                    }
                    
                    this.showError(errorMessage);
                    this.updateDebugInfo('è¯¦ç»†é”™è¯¯: ' + error.stack);
                }
            }
            
            setupControllers() {
                // è®¾ç½®æ§åˆ¶å™¨
                for (let i = 0; i < 2; i++) {
                    const controller = renderer.xr.getController(i);
                    
                    controller.addEventListener('select', (event) => {
                        this.onControllerSelect(event);
                    });
                    
                    scene.add(controller);
                    controllers.push(controller);
                    
                    // æ·»åŠ æ§åˆ¶å™¨å°„çº¿
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(0, 0, -1)
                    ]);
                    const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
                    controller.add(line);
                }
                
                this.updateDebugInfo('æ§åˆ¶å™¨å·²è®¾ç½® - æŒ‰ä¸‹è§¦å‘å™¨æµ‹è¯•æ¨¡å‹');
                
                // æ·»åŠ æµ‹è¯•è®¡æ•°å™¨
                this.testModelIndex = 0;
            }
            
            onControllerSelect(event) {
                // æµ‹è¯•åŠŸèƒ½ï¼šå¾ªç¯åˆ‡æ¢ä¹å™¨æ¨¡å‹
                const testInstruments = ['pattern1', 'pattern2'];
                const currentTest = testInstruments[this.testModelIndex % testInstruments.length];
                
                this.updateDebugInfo(`ğŸ® æ‰‹æŸ„è§¦å‘ - æµ‹è¯•åŠ è½½ ${currentTest}`);
                console.log('æ‰‹æŸ„è§¦å‘ï¼Œæµ‹è¯•åŠ è½½:', currentTest);
                
                // è§¦å‘æ¨¡å‹åˆ‡æ¢
                this.handleQRDetection(currentTest);
                
                this.testModelIndex++;
                
                // å¦‚æœæœ‰æ´»è·ƒæ¨¡å‹ï¼Œä¹Ÿå¯ä»¥æ—‹è½¬å®ƒ
                if (activeModel) {
                    activeModel.rotation.y += Math.PI / 4;
                    this.updateDebugInfo('æ¨¡å‹å·²æ—‹è½¬');
                }
            }
            
            handleQRDetection(qrData) {
                console.log('æ£€æµ‹åˆ°äºŒç»´ç :', qrData);
                
                const config = instrumentConfigs[qrData];
                if (!config) {
                    this.updateQRResult('æœªçŸ¥ç : ' + qrData);
                    return;
                }
                
                this.updateQRResult(qrData);
                this.updateCurrentInstrument(config.name);
                this.switchInstrument(qrData, config);
            }
            
            async switchInstrument(instrumentId, config) {
                try {
                    this.updateDebugInfo(`æ­£åœ¨åŠ è½½${config.name}...`);
                    
                    // ç§»é™¤å½“å‰æ¨¡å‹
                    if (activeModel) {
                        scene.remove(activeModel);
                        activeModel = null;
                    }
                    
                    // åŠ è½½æ–°æ¨¡å‹
                    const model = await this.loadModel(config.model);
                    if (model) {
                        // è®¾ç½®æ¨¡å‹ä½ç½®å’Œç¼©æ”¾
                        model.position.set(0, 0, -1.5); // åœ¨ç”¨æˆ·å‰æ–¹1.5ç±³
                        model.scale.set(...config.scale);
                        
                        // æ·»åŠ åˆ°åœºæ™¯
                        scene.add(model);
                        activeModel = model;
                        
                        // æ·»åŠ åŠ¨æ•ˆ
                        this.addDynamicEffects(model);
                        
                        // åˆ‡æ¢éŸ³é¢‘
                        await this.audioManager.switchAudio(config.audio);
                        this.updateAudioInfo(config.name + ' éŸ³ä¹');
                        this.enableAudioButton();
                        
                        this.updateDebugInfo(`âœ… ${config.name} åŠ è½½æˆåŠŸ`);
                        this.updateDebugInfo('ğŸ® æŒ‰æ‰‹æŸ„è§¦å‘å™¨æ—‹è½¬æ¨¡å‹');
                        this.updateDebugInfo('ğŸµ ç‚¹å‡»æ’­æ”¾æŒ‰é’®æµ‹è¯•éŸ³ä¹');
                    }
                    
                } catch (error) {
                    console.error('åˆ‡æ¢ä¹å™¨å¤±è´¥:', error);
                    this.updateDebugInfo('æ¨¡å‹åŠ è½½å¤±è´¥: ' + error.message);
                }
            }
            
            loadModel(modelPath) {
                return new Promise((resolve, reject) => {
                    if (!modelLoader) {
                        resolve(this.createFallbackModel(modelPath));
                        return;
                    }
                    
                    modelLoader.load(
                        modelPath,
                        (gltf) => {
                            // è®¾ç½®é˜´å½±
                            gltf.scene.traverse((child) => {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                }
                            });
                            
                            resolve(gltf.scene);
                        },
                        (progress) => {
                            // åŠ è½½è¿›åº¦
                            if (progress.total > 0) {
                                const percent = (progress.loaded / progress.total * 100).toFixed(1);
                                this.updateDebugInfo(`åŠ è½½è¿›åº¦: ${percent}%`);
                            }
                        },
                        (error) => {
                            console.error('GLTFåŠ è½½å¤±è´¥:', error);
                            this.updateDebugInfo('âš ï¸ GLTFåŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ¨¡å‹');
                            resolve(this.createFallbackModel(modelPath));
                        }
                    );
                });
            }
            
            createFallbackModel(modelPath) {
                console.log('åˆ›å»ºå¤‡ç”¨å‡ ä½•æ¨¡å‹:', modelPath);
                this.updateDebugInfo('ğŸ“¦ ä½¿ç”¨ç¨‹åºç”Ÿæˆçš„å¤‡ç”¨æ¨¡å‹');
                
                const group = new THREE.Group();
                
                if (modelPath.includes('model1')) {
                    // åˆ›å»ºçµç¶æ ·å¼çš„å‡ ä½•ä½“
                    const bodyGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                    const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    group.add(body);
                    
                    // çµç¶é¢ˆ
                    const neckGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8);
                    const neckMaterial = new THREE.MeshPhongMaterial({ color: 0x654321 });
                    const neck = new THREE.Mesh(neckGeometry, neckMaterial);
                    neck.position.y = 0.5;
                    group.add(neck);
                } else {
                    // åˆ›å»ºè‘«èŠ¦ä¸æ ·å¼çš„å‡ ä½•ä½“
                    const mainGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.6);
                    const mainMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                    const mainPipe = new THREE.Mesh(mainGeometry, mainMaterial);
                    group.add(mainPipe);
                    
                    // è‘«èŠ¦å¤´
                    const gourdGeometry = new THREE.SphereGeometry(0.08, 16, 16);
                    const gourdMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD700 });
                    const gourd = new THREE.Mesh(gourdGeometry, gourdMaterial);
                    gourd.position.y = 0.35;
                    group.add(gourd);
                }
                
                return group;
            }
            
            addDynamicEffects(model) {
                // åŠ¨æ€æè´¨å˜åŒ–
                const colors = [0xFF5733, 0x33FF57, 0x3357FF, 0xFFFF33, 0xFF33FF];
                let colorIndex = 0;
                
                const materialInterval = setInterval(() => {
                    if (!model.parent) {
                        clearInterval(materialInterval);
                        return;
                    }
                    
                    model.traverse((child) => {
                        if (child.isMesh && child.material && child.material.color) {
                            colorIndex = (colorIndex + 1) % colors.length;
                            child.material.color.setHex(colors[colorIndex]);
                        }
                    });
                }, 3000);
                
                // åŠ¨æ€å…‰ç…§ï¼ˆå‘¼å¸æ•ˆæœï¼‰
                const lightAnimation = () => {
                    if (!model.parent) return;
                    
                    const time = Date.now() * 0.001;
                    const intensity = 0.5 + Math.sin(time) * 0.3;
                    
                    // å¦‚æœæœ‰å…‰æºç»„ä»¶ï¼Œè°ƒæ•´å¼ºåº¦
                    model.traverse((child) => {
                        if (child.isLight) {
                            child.intensity = intensity;
                        }
                    });
                    
                    requestAnimationFrame(lightAnimation);
                };
                lightAnimation();
            }
            
            toggleAudio() {
                if (this.audioManager) {
                    this.audioManager.togglePlayback();
                }
            }
            
            onSessionEnd() {
                xrSession = null;
                xrReferenceSpace = null;
                if (this.xrWebGLBinding) {
                    this.xrWebGLBinding = null;
                }
                currentXRFrame = null;
                isWebXRActive = false;
                
                // åœæ­¢äºŒç»´ç æ£€æµ‹
                this.qrDetector.stopDetection();
                
                // é‡ç½®UI
                this.showStartUI();
                
                // æ¸…ç†åœºæ™¯
                if (activeModel) {
                    scene.remove(activeModel);
                    activeModel = null;
                }
                
                this.updateStatus('WebXRä¼šè¯å·²ç»“æŸ');
                this.updateDebugInfo('WebXRä¼šè¯å·²ç»“æŸ');
            }
            
            exitWebXR() {
                if (xrSession) {
                    xrSession.end();
                    xrSession = null;
                    xrReferenceSpace = null;
                    if (this.xrWebGLBinding) {
                        this.xrWebGLBinding = null;
                    }
                    currentXRFrame = null;
                    isWebXRActive = false;
                    
                    // åœæ­¢äºŒç»´ç æ£€æµ‹
                    this.qrDetector.stopDetection();
                    
                    // é‡ç½®UI
                    this.showStartUI();
                    
                    // æ¸…ç†åœºæ™¯
                    if (activeModel) {
                        scene.remove(activeModel);
                        activeModel = null;
                    }
                    
                    this.updateStatus('å·²é€€å‡ºWebXR');
                    this.updateDebugInfo('WebXRä¼šè¯å·²ç»“æŸ');
                }
            }
            
            render() {
                // åœ¨WebXRæ¨¡å¼ä¸‹è¿›è¡Œæ‘„åƒå¤´äºŒç»´ç æ£€æµ‹ï¼ˆå¦‚æœæ”¯æŒRaw Camera Accessï¼‰
                if (isWebXRActive && this.qrDetector && xrReferenceSpace && currentXRFrame) {
                    // åªæœ‰åœ¨æœ‰xrWebGLBindingæ—¶æ‰å°è¯•æ‘„åƒå¤´æ£€æµ‹
                    if (this.xrWebGLBinding) {
                        this.qrDetector.detectInXRFrame(currentXRFrame, xrReferenceSpace);
                    }
                    // å¦‚æœæ²¡æœ‰æ‘„åƒå¤´è®¿é—®ï¼ŒQRDetectoråœ¨åŸºç¡€æ¨¡å¼ä¸‹ä¸ä¼šæ‰§è¡Œä»»ä½•æ£€æµ‹
                }
                
                // æ¨¡å‹è‡ªåŠ¨æ—‹è½¬ï¼ˆå¦‚æœæ²¡æœ‰è¢«æ‰‹åŠ¨æ§åˆ¶ï¼‰
                if (activeModel && isWebXRActive) {
                    activeModel.rotation.y += 0.005;
                }
                
                renderer.render(scene, camera);
            }
            
            // UIæ›´æ–°æ–¹æ³•
            showStartUI() {
                document.getElementById('startContainer').style.display = 'block';
                document.getElementById('info').style.display = 'none';
                document.getElementById('controls').style.display = 'none';
                document.getElementById('debugInfo').style.display = 'none';
                document.getElementById('detectionOverlay').style.display = 'none';
            }
            
            showWebXRUI() {
                document.getElementById('startContainer').style.display = 'none';
                document.getElementById('info').style.display = 'block';
                document.getElementById('controls').style.display = 'block';
                document.getElementById('debugInfo').style.display = 'block';
                document.getElementById('detectionOverlay').style.display = 'block';
            }
            
            updateStatus(status) {
                document.getElementById('status').textContent = status;
                
                // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
                const indicator = document.querySelector('.status-indicator');
                indicator.className = 'status-indicator';
                
                if (status.includes('å‡†å¤‡')) {
                    indicator.classList.add('status-ready');
                } else if (status.includes('æ‰«æ') || status.includes('WebXRè¿è¡Œä¸­')) {
                    indicator.classList.add('status-scanning');
                } else if (status.includes('æ£€æµ‹åˆ°')) {
                    indicator.classList.add('status-detected');
                } else if (status.includes('é”™è¯¯') || status.includes('å¤±è´¥')) {
                    indicator.classList.add('status-error');
                }
            }
            
            updateQRResult(result) {
                document.getElementById('qrResult').textContent = result;
            }
            
            updateCurrentInstrument(instrument) {
                document.getElementById('currentInstrument').textContent = instrument;
            }
            
            updateAudioInfo(info) {
                document.getElementById('audioInfo').textContent = info;
            }
            
            updateDebugInfo(info) {
                const debugText = document.getElementById('debugText');
                const timestamp = new Date().toLocaleTimeString();
                debugText.innerHTML += `<div>${timestamp}: ${info}</div>`;
                debugText.scrollTop = debugText.scrollHeight;
            }
            
            enableAudioButton() {
                const button = document.getElementById('playButton');
                button.disabled = false;
                button.style.backgroundColor = '#007BFF';
            }
            
            showError(message) {
                document.getElementById('startContainer').innerHTML = 
                    `<h2>âŒ é”™è¯¯</h2><p>${message}</p>` +
                    '<button onclick="location.reload()" class="btn">é‡æ–°åŠ è½½</button>';
            }
        }
        
        // éŸ³é¢‘ç®¡ç†å™¨
        class AudioManager {
            constructor() {
                this.audioCache = new Map();
                this.currentAudio = null;
                this.isPlaying = false;
            }
            
            async preloadAudio(configs) {
                for (const [key, config] of Object.entries(configs)) {
                    try {
                        const audio = new Audio();
                        audio.src = config.audio;
                        audio.preload = 'auto';
                        
                        await new Promise((resolve) => {
                            audio.oncanplaythrough = resolve;
                            audio.onerror = resolve;
                            audio.load();
                        });
                        
                        this.audioCache.set(config.audio, audio);
                        console.log('éŸ³é¢‘é¢„åŠ è½½æˆåŠŸ:', config.audio);
                    } catch (error) {
                        console.error('éŸ³é¢‘é¢„åŠ è½½å¤±è´¥:', error);
                    }
                }
            }
            
            async switchAudio(audioPath) {
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio.currentTime = 0;
                }
                
                this.currentAudio = this.audioCache.get(audioPath);
                this.isPlaying = false;
                this.updatePlayButton();
            }
            
            togglePlayback() {
                if (!this.currentAudio) return;
                
                if (this.isPlaying) {
                    this.currentAudio.pause();
                    this.isPlaying = false;
                } else {
                    this.currentAudio.play().then(() => {
                        this.isPlaying = true;
                    }).catch((error) => {
                        console.error('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error);
                    });
                }
                this.updatePlayButton();
            }
            
            updatePlayButton() {
                const button = document.getElementById('playButton');
                if (button) {
                    button.textContent = this.isPlaying ? 'æš‚åœéŸ³ä¹' : 'æ’­æ”¾éŸ³ä¹';
                }
            }
        }
        
        // äºŒç»´ç æ£€æµ‹å™¨ - WebXR Raw Camera Accessç‰ˆæœ¬
        class QRDetector {
            constructor() {
                this.canvas = document.getElementById('qrCanvas');
                this.context = this.canvas.getContext('2d');
                this.isDetecting = false;
                this.onDetectionCallback = null;
                this.lastDetectionTime = 0;
                this.detectionCooldown = 1000; // 1ç§’å†·å´æ—¶é—´
                this.detectionAttempts = 0;
                this.gl = null;
                this.xrBinding = null;
                this.cameraImageCanvas = null;
                this.cameraImageContext = null;
            }
            
            startWebXRDetection(callback, gl, xrBinding) {
                this.onDetectionCallback = callback;
                this.isDetecting = true;
                this.detectionAttempts = 0;
                this.gl = gl;
                this.xrBinding = xrBinding;
                
                // åˆ›å»ºç”¨äºæ‘„åƒå¤´å›¾åƒçš„canvas
                this.cameraImageCanvas = document.createElement('canvas');
                this.cameraImageContext = this.cameraImageCanvas.getContext('2d');
                
                if (window.app) {
                    window.app.updateDebugInfo('ğŸ¥ å¼€å§‹Raw Camera Accessæ£€æµ‹...');
                    window.app.updateDebugInfo('âœ… æ‘„åƒå¤´è®¿é—®æƒé™å·²è·å–');
                    window.app.updateDebugInfo('ğŸ“± æ­£åœ¨ç›‘å¬äºŒç»´ç ...');
                }
                
                console.log('å¼€å§‹WebXR Raw Camera Accessæ£€æµ‹');
            }
            
            startBasicDetection(callback) {
                // åŸºç¡€æ£€æµ‹æ–¹å¼ï¼ˆå›é€€æ–¹æ¡ˆï¼‰
                this.onDetectionCallback = callback;
                this.isDetecting = true;
                this.detectionAttempts = 0;
                
                if (window.app) {
                    window.app.updateDebugInfo('ğŸ”„ å¯åŠ¨åŸºç¡€æ£€æµ‹æ¨¡å¼...');
                    window.app.updateDebugInfo('âš ï¸ Raw Camera Accessä¸å¯ç”¨');
                    window.app.updateDebugInfo('ğŸ’¡ ä¸»è¦ä½¿ç”¨æ‰‹æŸ„äº¤äº’');
                }
                
                console.log('å¼€å§‹åŸºç¡€WebXRæ£€æµ‹æ¨¡å¼');
            }
            
            detectInXRFrame(frame, referenceSpace) {
                if (!this.isDetecting || !this.onDetectionCallback || !this.xrBinding) {
                    return; // å¦‚æœæ²¡æœ‰XRç»‘å®šï¼Œç›´æ¥è¿”å›
                }
                
                const now = Date.now();
                if (now - this.lastDetectionTime < 200) return; // é™åˆ¶æ£€æµ‹é¢‘ç‡
                
                this.detectionAttempts++;
                
                try {
                    // è·å–viewer poseæ¥è®¿é—®views
                    const pose = frame.getViewerPose(referenceSpace);
                    if (!pose || !pose.views || pose.views.length === 0) {
                        return;
                    }
                    
                    // å–ç¬¬ä¸€ä¸ªviewï¼ˆé€šå¸¸æ˜¯ä¸»è§†å›¾ï¼‰
                    const view = pose.views[0];
                    
                    // æ£€æŸ¥viewæ˜¯å¦æœ‰cameraå±æ€§ï¼ˆRaw Camera Access APIï¼‰
                    if (!view.camera) {
                        if (this.detectionAttempts % 100 === 1) {
                            console.log('Viewæ²¡æœ‰cameraå±æ€§ï¼Œå¯èƒ½éœ€è¦å¯ç”¨å®éªŒç‰¹æ€§');
                            if (window.app) {
                                window.app.updateDebugInfo('âš ï¸ æœªæ£€æµ‹åˆ°æ‘„åƒå¤´è®¿é—®');
                                window.app.updateDebugInfo('è¯·ç¡®ä¿å·²å¯ç”¨chrome://flagsä¸­çš„å®éªŒç‰¹æ€§');
                            }
                        }
                        return;
                    }
                    
                    // è·å–æ‘„åƒå¤´å›¾åƒä½œä¸ºWebGLçº¹ç†
                    let cameraTexture;
                    try {
                        cameraTexture = this.xrBinding.getCameraImage(view.camera);
                    } catch (cameraError) {
                        if (this.detectionAttempts % 50 === 1) {
                            console.log('è·å–æ‘„åƒå¤´å›¾åƒå¤±è´¥:', cameraError);
                            if (window.app) {
                                window.app.updateDebugInfo('âŒ æ‘„åƒå¤´å›¾åƒè·å–å¤±è´¥');
                                window.app.updateDebugInfo('é”™è¯¯: ' + cameraError.message);
                            }
                        }
                        return;
                    }
                    
                    if (!cameraTexture) {
                        if (this.detectionAttempts % 50 === 1) {
                            console.log('æ‘„åƒå¤´çº¹ç†ä¸ºç©º');
                        }
                        return;
                    }
                    
                    // æŠ¥å‘ŠæˆåŠŸçŠ¶æ€
                    if (this.detectionAttempts === 1) {
                        console.log('âœ… æˆåŠŸè·å–åˆ°æ‘„åƒå¤´çº¹ç†ï¼');
                        if (window.app) {
                            window.app.updateDebugInfo('ğŸ‰ æˆåŠŸè·å–æ‘„åƒå¤´æ•°æ®ï¼');
                            window.app.updateDebugInfo('ğŸ“¸ å¼€å§‹äºŒç»´ç è¯†åˆ«...');
                        }
                    }
                    
                    // å°†WebGLçº¹ç†è½¬æ¢ä¸ºåƒç´ æ•°æ®
                    const imageData = this.extractPixelsFromTexture(cameraTexture, view);
                    if (!imageData) {
                        return;
                    }
                    
                    // ä½¿ç”¨jsQRæ£€æµ‹äºŒç»´ç 
                    const code = jsQR(imageData.data, imageData.width, imageData.height, {
                        inversionAttempts: 'attemptBoth'
                    });
                    
                    if (code && (now - this.lastDetectionTime > this.detectionCooldown)) {
                        console.log('ğŸ¯ æ‘„åƒå¤´ä¸­æ£€æµ‹åˆ°äºŒç»´ç :', code.data);
                        if (window.app) {
                            window.app.updateDebugInfo('ğŸ¯ æ£€æµ‹åˆ°äºŒç»´ç : ' + code.data);
                        }
                        this.onDetectionCallback(code.data);
                        this.lastDetectionTime = now;
                        
                        // çŸ­æš‚åœæ­¢æ£€æµ‹ï¼Œé¿å…é‡å¤è§¦å‘
                        this.isDetecting = false;
                        setTimeout(() => {
                            this.isDetecting = true;
                        }, this.detectionCooldown);
                    }
                    
                    // å®šæœŸæŠ¥å‘Šæ£€æµ‹çŠ¶æ€
                    if (this.detectionAttempts % 100 === 0) {
                        if (window.app) {
                            window.app.updateDebugInfo(`ğŸ“± å·²æ£€æµ‹ ${this.detectionAttempts} å¸§`);
                        }
                    }
                    
                } catch (error) {
                    if (this.detectionAttempts <= 3) {
                        console.error('WebXRæ‘„åƒå¤´æ£€æµ‹é”™è¯¯:', error);
                        if (window.app) {
                            window.app.updateDebugInfo('æ£€æµ‹é”™è¯¯: ' + error.message);
                        }
                    }
                }
                
                this.lastDetectionTime = now;
            }
            
            extractPixelsFromTexture(texture, view) {
                try {
                    // åˆ›å»ºå¸§ç¼“å†²æ¥è¯»å–çº¹ç†æ•°æ®
                    const framebuffer = this.gl.createFramebuffer();
                    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, framebuffer);
                    
                    // å°†æ‘„åƒå¤´çº¹ç†ç»‘å®šåˆ°å¸§ç¼“å†²
                    this.gl.framebufferTexture2D(
                        this.gl.FRAMEBUFFER, 
                        this.gl.COLOR_ATTACHMENT0, 
                        this.gl.TEXTURE_2D, 
                        texture, 
                        0
                    );
                    
                    // æ£€æŸ¥å¸§ç¼“å†²çŠ¶æ€
                    if (this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER) !== this.gl.FRAMEBUFFER_COMPLETE) {
                        console.log('å¸§ç¼“å†²ä¸å®Œæ•´');
                        this.gl.deleteFramebuffer(framebuffer);
                        return null;
                    }
                    
                    // è·å–çº¹ç†å°ºå¯¸ï¼ˆå¯èƒ½éœ€è¦æ ¹æ®viewçš„å°ºå¯¸è°ƒæ•´ï¼‰
                    const width = 640;  // å°è¯•å¸¸è§çš„åˆ†è¾¨ç‡
                    const height = 480;
                    
                    // è¯»å–åƒç´ æ•°æ®
                    const pixels = new Uint8Array(width * height * 4);
                    this.gl.readPixels(0, 0, width, height, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pixels);
                    
                    // æ¸…ç†
                    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
                    this.gl.deleteFramebuffer(framebuffer);
                    
                    // åˆ›å»ºImageDataå¯¹è±¡
                    const imageData = new ImageData(new Uint8ClampedArray(pixels), width, height);
                    
                    return imageData;
                    
                } catch (error) {
                    console.error('æå–çº¹ç†åƒç´ å¤±è´¥:', error);
                    if (window.app) {
                        window.app.updateDebugInfo('åƒç´ æå–å¤±è´¥: ' + error.message);
                    }
                    return null;
                }
            }
            
            stopDetection() {
                this.isDetecting = false;
                this.onDetectionCallback = null;
                this.detectionAttempts = 0;
                
                // æ¸…ç†æ‘„åƒå¤´ç›¸å…³èµ„æº
                if (this.gl) {
                    this.gl = null;
                }
                if (this.xrBinding) {
                    this.xrBinding = null;
                }
                
                if (this.cameraImageCanvas) {
                    this.cameraImageCanvas = null;
                    this.cameraImageContext = null;
                }
                
                console.log('äºŒç»´ç æ£€æµ‹å·²åœæ­¢');
                if (window.app) {
                    window.app.updateDebugInfo('äºŒç»´ç æ£€æµ‹å·²åœæ­¢');
                }
            }
        }
        
        // å¯åŠ¨åº”ç”¨
        document.addEventListener('DOMContentLoaded', () => {
            console.log('å¯åŠ¨WebXRä¹å™¨åº”ç”¨...');
            console.log('ç¯å¢ƒæ£€æŸ¥:');
            console.log('- THREE.jsç‰ˆæœ¬:', THREE.REVISION);
            console.log('- jsQRå¯ç”¨:', typeof jsQR !== 'undefined');
            console.log('- WebXRå¯ç”¨:', !!navigator.xr);
            console.log('- GLTFLoaderå¯ç”¨:', typeof THREE.GLTFLoader !== 'undefined');
            
            try {
                new WebXRInstrumentApp();
            } catch (error) {
                console.error('åº”ç”¨å¯åŠ¨å¤±è´¥:', error);
                document.getElementById('startContainer').innerHTML = 
                    '<h2>âŒ å¯åŠ¨å¤±è´¥</h2><p>é”™è¯¯: ' + error.message + '</p>' +
                    '<button onclick="location.reload()" class="btn">é‡æ–°åŠ è½½</button>';
            }
        });
        
        // å…¨å±€é”™è¯¯å¤„ç†
        window.onerror = function(message, source, lineno, colno, error) {
            console.error("å…¨å±€é”™è¯¯:", {
                message, source, lineno, colno, error
            });
        };
    </script>
</body>
</html>