<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>å²­å—ä¹å™¨WebXRå¢å¼ºç°å®ä½“éªŒ</title>
    
    <!-- Three.jsæ ¸å¿ƒåº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="./js/GLTFLoader.js"></script>
    <script src="./js/DRACOLoader.js"></script>
    
    <!-- äºŒç»´ç æ£€æµ‹åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsqr/1.4.0/jsQR.min.js"></script>
    
    <style>
        body {
            margin: 0;
            background: #000;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #startContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00ff00;
        }
        
        #startWebXR {
            padding: 20px 40px;
            font-size: 18px;
            background: linear-gradient(45deg, #007BFF, #0056b3);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 4px 15px rgba(0,123,255,0.3);
            transition: all 0.3s ease;
        }
        
        #startWebXR:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,123,255,0.4);
        }
        
        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            z-index: 100;
            display: none;
            border: 1px solid #00ff00;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            display: none;
            border: 1px solid #007BFF;
        }
        
        #debugInfo {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 100;
            display: none;
            max-height: 200px;
            overflow-y: auto;
            min-width: 200px;
            border: 1px solid #ffc107;
        }
        
        .btn {
            padding: 10px 20px;
            margin: 5px;
            background: #007BFF;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            background: #0056b3;
            transform: translateY(-1px);
        }
        
        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }
        
        #qrCanvas {
            display: none;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-ready { background: #28a745; }
        .status-scanning { background: #ffc107; animation: pulse 1s infinite; }
        .status-detected { background: #007BFF; }
        .status-error { background: #dc3545; }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .detection-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 3px solid #00ff00;
            border-radius: 20px;
            z-index: 50;
            display: none;
            animation: scanAnimation 2s infinite;
        }
        
        @keyframes scanAnimation {
            0%, 100% { border-color: #00ff00; }
            50% { border-color: #ffff00; }
        }
        
        .detection-overlay::before {
            content: 'å°†äºŒç»´ç æ”¾åœ¨æ¡†å†…\Aæˆ–æŒ‰æ‰‹æŸ„è§¦å‘å™¨æµ‹è¯•';
            position: absolute;
            top: -50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: #00ff00;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            white-space: pre;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="startContainer">
        <h2>ğŸµ å²­å—ä¹å™¨WebXRä½“éªŒ</h2>
        <p>ä½¿ç”¨VRå¤´æ˜¾è¿›å…¥å¢å¼ºç°å®ä¹å™¨ä¸–ç•Œ</p>
        <button id="startWebXR">å¯åŠ¨WebXR ARä½“éªŒ</button>
        <p><small>
            âœ… æ”¯æŒMeta Quest 3/3S<br>
            âœ… å½©è‰²æ‘„åƒå¤´é€è§†<br>
            âœ… äºŒç»´ç è‡ªåŠ¨æ£€æµ‹<br>
            âœ… æ‰‹æŸ„/æ‰‹åŠ¿äº¤äº’<br>
            <br>
            <strong>âš ï¸ é¦–æ¬¡ä½¿ç”¨è¯·ç¡®ä¿ï¼š</strong><br>
            1. åœ¨Questæµè§ˆå™¨è¾“å…¥ chrome://flags<br>
            2. å¼€å¯ "WebXR incubations"<br>
            3. é‡å¯æµè§ˆå™¨
        </small></p>
    </div>
    
    <div id="info">
        <div><span class="status-indicator status-ready"></span>çŠ¶æ€: <span id="status">å‡†å¤‡å°±ç»ª</span></div>
        <div>æ£€æµ‹åˆ°: <span id="qrResult">æ— </span></div>
        <div>å½“å‰ä¹å™¨: <span id="currentInstrument">æ— </span></div>
        <div id="instructionText">
            <strong>ğŸ® ä½¿ç”¨æ–¹æ³•ï¼š</strong><br>
            1. æŒ‰æ‰‹æŸ„è§¦å‘å™¨å¾ªç¯æµ‹è¯•ä¹å™¨<br>
            2. æˆ–å°è¯•å°†äºŒç»´ç ç½®äºè§†é‡ä¸­å¿ƒ<br>
            <small>âš ï¸ æ³¨æ„ï¼šQuestç›®å‰é™åˆ¶æ‘„åƒå¤´è®¿é—®</small>
        </div>
    </div>
    
    <div id="controls">
        <button id="playButton" class="btn" disabled>æ’­æ”¾éŸ³ä¹</button>
        <button id="exitWebXR" class="btn">é€€å‡ºAR</button>
        <div style="margin-top: 10px;">
            <span id="audioInfo">æ— éŸ³é¢‘</span>
        </div>
    </div>
    
    <div id="debugInfo">
        <div><strong>è°ƒè¯•ä¿¡æ¯:</strong></div>
        <div id="debugText"></div>
    </div>
    
    <div class="detection-overlay" id="detectionOverlay"></div>
    <canvas id="qrCanvas"></canvas>

    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer;
        let xrSession = null;
        let xrReferenceSpace = null;
        let isWebXRActive = false;
        
        // ä¹å™¨é…ç½®
        const instrumentConfigs = {
            'pattern1': {
                model: 'model1.gltf',
                audio: 'audio1.mp3',
                info: 'info1.txt',
                scale: [0.006, 0.006, 0.006],
                name: 'çµç¶'
            },
            'pattern2': {
                model: 'model2.gltf', 
                audio: 'audio2.mp3',
                info: 'info2.txt',
                scale: [0.03, 0.03, 0.03],
                name: 'è‘«èŠ¦ä¸'
            }
        };
        
        // åº”ç”¨çŠ¶æ€
        let currentInstrument = null;
        let activeModel = null;
        let audioManager = null;
        let qrDetector = null;
        let modelLoader = null;
        let controllers = [];
        
        // åˆå§‹åŒ–åº”ç”¨
        class WebXRInstrumentApp {
            constructor() {
                this.init();
            }
            
            async init() {
                console.log('åˆå§‹åŒ–WebXRä¹å™¨åº”ç”¨...');
                
                // æ£€æŸ¥WebXRæ”¯æŒ
                if (!navigator.xr) {
                    this.showError('æ­¤è®¾å¤‡ä¸æ”¯æŒWebXR API');
                    return;
                }
                
                // æ£€æŸ¥ARæ”¯æŒ
                const arSupported = await navigator.xr.isSessionSupported('immersive-ar');
                if (!arSupported) {
                    this.showError('æ­¤è®¾å¤‡ä¸æ”¯æŒWebXR ARæ¨¡å¼\nè¯·ç¡®ä¿ï¼š\n1. ä½¿ç”¨Quest 3/3Sæˆ–å…¼å®¹è®¾å¤‡\n2. æµè§ˆå™¨å·²å¼€å¯WebXRå®éªŒç‰¹æ€§');
                    return;
                }
                
                // æ£€æŸ¥å¯é€‰ç‰¹æ€§æ”¯æŒ
                try {
                    const localFloorSupported = await navigator.xr.isSessionSupported('immersive-ar', {
                        optionalFeatures: ['local-floor']
                    });
                    this.updateDebugInfo(`local-flooræ”¯æŒ: ${localFloorSupported ? 'æ˜¯' : 'å¦'}`);
                } catch (e) {
                    this.updateDebugInfo('æ— æ³•æ£€æŸ¥local-flooræ”¯æŒ');
                }
                
                // åˆå§‹åŒ–Three.js
                this.setupThreeJS();
                
                // åˆå§‹åŒ–æ¨¡å‹åŠ è½½å™¨
                this.initModelLoader();
                
                // åˆå§‹åŒ–éŸ³é¢‘ç®¡ç†å™¨
                this.audioManager = new AudioManager();
                await this.audioManager.preloadAudio(instrumentConfigs);
                
                // åˆå§‹åŒ–äºŒç»´ç æ£€æµ‹å™¨
                this.qrDetector = new QRDetector();
                
                // è®¾ç½®UIäº‹ä»¶
                this.setupUI();
                
                this.updateDebugInfo('åº”ç”¨åˆå§‹åŒ–å®Œæˆ');
                console.log('WebXRä¹å™¨åº”ç”¨åˆå§‹åŒ–å®Œæˆ');
            }
            
            setupThreeJS() {
                // åˆ›å»ºåœºæ™¯
                scene = new THREE.Scene();
                
                // åˆ›å»ºç›¸æœº
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 1.6, 3);
                
                // åˆ›å»ºæ¸²æŸ“å™¨ - Questä¼˜åŒ–è®¾ç½®
                renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true, // å…³é”®ï¼šå¯ç”¨é€æ˜èƒŒæ™¯ç”¨äºARé€è§†
                    powerPreference: 'high-performance', // Questæ€§èƒ½ä¼˜åŒ–
                    stencil: false // Questæ€§èƒ½ä¼˜åŒ–
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // å¯ç”¨WebXR
                renderer.xr.enabled = true;
                
                document.body.appendChild(renderer.domElement);
                
                // æ·»åŠ å…‰ç…§
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                // å¯åŠ¨æ¸²æŸ“å¾ªç¯
                renderer.setAnimationLoop(this.render.bind(this));
                
                console.log('Three.jsè®¾ç½®å®Œæˆ');
            }
            
            initModelLoader() {
                if (typeof THREE.GLTFLoader === 'function') {
                    modelLoader = new THREE.GLTFLoader();
                    
                    if (typeof THREE.DRACOLoader === 'function') {
                        const dracoLoader = new THREE.DRACOLoader();
                        dracoLoader.setDecoderPath('./js/draco/');
                        dracoLoader.preload();
                        modelLoader.setDRACOLoader(dracoLoader);
                        this.updateDebugInfo('GLTFLoader + DRACOLoader å·²å°±ç»ª');
                    } else {
                        this.updateDebugInfo('GLTFLoader å·²å°±ç»ªï¼ˆæ— Dracoæ”¯æŒï¼‰');
                    }
                } else {
                    this.updateDebugInfo('GLTFLoader æœªæ‰¾åˆ°ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶');
                }
            }
            
            setupUI() {
                document.getElementById('startWebXR').addEventListener('click', () => {
                    this.startWebXR();
                });
                
                document.getElementById('playButton').addEventListener('click', () => {
                    this.toggleAudio();
                });
                
                document.getElementById('exitWebXR').addEventListener('click', () => {
                    this.exitWebXR();
                });
            }
            
            async startWebXR() {
                try {
                    this.updateStatus('å¯åŠ¨WebXR...');
                    this.updateDebugInfo('è¯·æ±‚WebXR ARä¼šè¯...');
                    
                    // è¯·æ±‚WebXR ARä¼šè¯ - æ·»åŠ å›¾åƒè¿½è¸ªç‰¹æ€§
                    xrSession = await navigator.xr.requestSession('immersive-ar', {
                        optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking', 'image-tracking']
                    });
                    
                    // è®¾ç½®æ¸²æŸ“å™¨ - ç¡®ä¿å…¼å®¹æ€§
                    await renderer.xr.setSession(xrSession);
                    
                    // ç­‰å¾…ä¼šè¯å®Œå…¨åˆå§‹åŒ–
                    await new Promise(resolve => {
                        xrSession.addEventListener('end', () => {
                            this.onSessionEnd();
                        });
                        // ç»™ä¼šè¯ä¸€äº›æ—¶é—´æ¥å®Œå…¨åˆå§‹åŒ–
                        setTimeout(resolve, 100);
                    });
                    
                    // è·å–å‚è€ƒç©ºé—´ - å°è¯•å¤šç§ç±»å‹ä»¥ç¡®ä¿å…¼å®¹æ€§
                    try {
                        xrReferenceSpace = await xrSession.requestReferenceSpace('local-floor');
                        this.updateDebugInfo('ä½¿ç”¨local-floorå‚è€ƒç©ºé—´');
                    } catch (e) {
                        try {
                            xrReferenceSpace = await xrSession.requestReferenceSpace('local');
                            this.updateDebugInfo('é™çº§åˆ°localå‚è€ƒç©ºé—´');
                        } catch (e2) {
                            try {
                                xrReferenceSpace = await xrSession.requestReferenceSpace('viewer');
                                this.updateDebugInfo('é™çº§åˆ°viewerå‚è€ƒç©ºé—´');
                            } catch (e3) {
                                throw new Error('æ— æ³•è·å–ä»»ä½•æ”¯æŒçš„å‚è€ƒç©ºé—´ç±»å‹');
                            }
                        }
                    }
                    
                    // è®¾ç½®æ§åˆ¶å™¨
                    this.setupControllers();
                    
                    // å¯åŠ¨äºŒç»´ç æ£€æµ‹ï¼ˆæœ‰é™åŠŸèƒ½ï¼‰
                    this.qrDetector.startWebXRDetection((qrData) => {
                        this.handleQRDetection(qrData);
                    });
                    
                    // æ›´æ–°UI
                    this.showWebXRUI();
                    
                    isWebXRActive = true;
                    this.updateStatus('WebXRè¿è¡Œä¸­');
                    this.updateDebugInfo('âœ… WebXR ARä¼šè¯å·²å¯åŠ¨');
                    this.updateDebugInfo('');
                    this.updateDebugInfo('ğŸ® å¿«é€Ÿæµ‹è¯•ï¼šæŒ‰æ‰‹æŸ„è§¦å‘å™¨');
                    this.updateDebugInfo('ğŸ“± äºŒç»´ç æ£€æµ‹ï¼šåŠŸèƒ½æœ‰é™');
                    this.updateDebugInfo('   (Questæµè§ˆå™¨é™åˆ¶æ‘„åƒå¤´è®¿é—®)');
                    this.updateDebugInfo('');
                    this.updateDebugInfo('ğŸ’¡ å»ºè®®ï¼šä¸»è¦ä½¿ç”¨æ‰‹æŸ„è¿›è¡Œäº¤äº’');
                    
                    console.log('WebXRå¯åŠ¨æˆåŠŸ');
                    
                } catch (error) {
                    console.error('WebXRå¯åŠ¨å¤±è´¥:', error);
                    
                    let errorMessage = 'WebXRå¯åŠ¨å¤±è´¥: ';
                    if (error.message.includes('requestReferenceSpace')) {
                        errorMessage += 'å‚è€ƒç©ºé—´ä¸æ”¯æŒ\nè¯·æ£€æŸ¥Questè®¾å¤‡è®¾ç½®';
                    } else if (error.message.includes('requestSession')) {
                        errorMessage += 'æ— æ³•åˆ›å»ºARä¼šè¯\nè¯·ç¡®ä¿è®¾å¤‡æ”¯æŒå¹¶å·²å¼€å¯ARæ¨¡å¼';
                    } else {
                        errorMessage += error.message;
                    }
                    
                    this.showError(errorMessage);
                    this.updateDebugInfo('è¯¦ç»†é”™è¯¯: ' + error.stack);
                }
            }
            
            setupControllers() {
                // è®¾ç½®æ§åˆ¶å™¨
                for (let i = 0; i < 2; i++) {
                    const controller = renderer.xr.getController(i);
                    
                    controller.addEventListener('select', (event) => {
                        this.onControllerSelect(event);
                    });
                    
                    scene.add(controller);
                    controllers.push(controller);
                    
                    // æ·»åŠ æ§åˆ¶å™¨å°„çº¿
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(0, 0, -1)
                    ]);
                    const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
                    controller.add(line);
                }
                
                this.updateDebugInfo('æ§åˆ¶å™¨å·²è®¾ç½® - æŒ‰ä¸‹è§¦å‘å™¨æµ‹è¯•æ¨¡å‹');
                
                // æ·»åŠ æµ‹è¯•è®¡æ•°å™¨
                this.testModelIndex = 0;
            }
            
            onControllerSelect(event) {
                // æµ‹è¯•åŠŸèƒ½ï¼šå¾ªç¯åˆ‡æ¢ä¹å™¨æ¨¡å‹
                const testInstruments = ['pattern1', 'pattern2'];
                const currentTest = testInstruments[this.testModelIndex % testInstruments.length];
                
                this.updateDebugInfo(`ğŸ® æ‰‹æŸ„è§¦å‘ - æµ‹è¯•åŠ è½½ ${currentTest}`);
                console.log('æ‰‹æŸ„è§¦å‘ï¼Œæµ‹è¯•åŠ è½½:', currentTest);
                
                // è§¦å‘æ¨¡å‹åˆ‡æ¢
                this.handleQRDetection(currentTest);
                
                this.testModelIndex++;
                
                // å¦‚æœæœ‰æ´»è·ƒæ¨¡å‹ï¼Œä¹Ÿå¯ä»¥æ—‹è½¬å®ƒ
                if (activeModel) {
                    activeModel.rotation.y += Math.PI / 4;
                    this.updateDebugInfo('æ¨¡å‹å·²æ—‹è½¬');
                }
            }
            
            handleQRDetection(qrData) {
                console.log('æ£€æµ‹åˆ°äºŒç»´ç :', qrData);
                
                const config = instrumentConfigs[qrData];
                if (!config) {
                    this.updateQRResult('æœªçŸ¥ç : ' + qrData);
                    return;
                }
                
                this.updateQRResult(qrData);
                this.updateCurrentInstrument(config.name);
                this.switchInstrument(qrData, config);
            }
            
            async switchInstrument(instrumentId, config) {
                try {
                    this.updateDebugInfo(`æ­£åœ¨åŠ è½½${config.name}...`);
                    
                    // ç§»é™¤å½“å‰æ¨¡å‹
                    if (activeModel) {
                        scene.remove(activeModel);
                        activeModel = null;
                    }
                    
                    // åŠ è½½æ–°æ¨¡å‹
                    const model = await this.loadModel(config.model);
                    if (model) {
                        // è®¾ç½®æ¨¡å‹ä½ç½®å’Œç¼©æ”¾
                        model.position.set(0, 0.5, -0.6); // åœ¨ç”¨æˆ·å‰æ–¹1.5ç±³
                        model.scale.set(...config.scale);
                        
                        // æ·»åŠ åˆ°åœºæ™¯
                        scene.add(model);
                        activeModel = model;
                        
                        // æ·»åŠ åŠ¨æ•ˆ
                        //this.addDynamicEffects(model);
                        
                        // åˆ‡æ¢éŸ³é¢‘
                        await this.audioManager.switchAudio(config.audio);
                        this.updateAudioInfo(config.name + ' éŸ³ä¹');
                        this.enableAudioButton();
                        
                        this.updateDebugInfo(`âœ… ${config.name} åŠ è½½æˆåŠŸ`);
                        this.updateDebugInfo('ğŸ® æŒ‰æ‰‹æŸ„è§¦å‘å™¨æ—‹è½¬æ¨¡å‹');
                        this.updateDebugInfo('ğŸµ ç‚¹å‡»æ’­æ”¾æŒ‰é’®æµ‹è¯•éŸ³ä¹');
                    }
                    
                } catch (error) {
                    console.error('åˆ‡æ¢ä¹å™¨å¤±è´¥:', error);
                    this.updateDebugInfo('æ¨¡å‹åŠ è½½å¤±è´¥: ' + error.message);
                }
            }
            
            loadModel(modelPath) {
                return new Promise((resolve, reject) => {
                    if (!modelLoader) {
                        resolve(this.createFallbackModel(modelPath));
                        return;
                    }
                    
                    modelLoader.load(
                        modelPath,
                        (gltf) => {
                            // è®¾ç½®é˜´å½±
                            gltf.scene.traverse((child) => {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                }
                            });
                            
                            resolve(gltf.scene);
                        },
                        (progress) => {
                            // åŠ è½½è¿›åº¦
                            if (progress.total > 0) {
                                const percent = (progress.loaded / progress.total * 100).toFixed(1);
                                this.updateDebugInfo(`åŠ è½½è¿›åº¦: ${percent}%`);
                            }
                        },
                        (error) => {
                            console.error('GLTFåŠ è½½å¤±è´¥:', error);
                            this.updateDebugInfo('âš ï¸ GLTFåŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ¨¡å‹');
                            resolve(this.createFallbackModel(modelPath));
                        }
                    );
                });
            }
            
            createFallbackModel(modelPath) {
                console.log('åˆ›å»ºå¤‡ç”¨å‡ ä½•æ¨¡å‹:', modelPath);
                this.updateDebugInfo('ğŸ“¦ ä½¿ç”¨ç¨‹åºç”Ÿæˆçš„å¤‡ç”¨æ¨¡å‹');
                
                const group = new THREE.Group();
                
                if (modelPath.includes('model1')) {
                    // åˆ›å»ºçµç¶æ ·å¼çš„å‡ ä½•ä½“
                    const bodyGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                    const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    group.add(body);
                    
                    // çµç¶é¢ˆ
                    const neckGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8);
                    const neckMaterial = new THREE.MeshPhongMaterial({ color: 0x654321 });
                    const neck = new THREE.Mesh(neckGeometry, neckMaterial);
                    neck.position.y = 0.5;
                    group.add(neck);
                } else {
                    // åˆ›å»ºè‘«èŠ¦ä¸æ ·å¼çš„å‡ ä½•ä½“
                    const mainGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.6);
                    const mainMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                    const mainPipe = new THREE.Mesh(mainGeometry, mainMaterial);
                    group.add(mainPipe);
                    
                    // è‘«èŠ¦å¤´
                    const gourdGeometry = new THREE.SphereGeometry(0.08, 16, 16);
                    const gourdMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD700 });
                    const gourd = new THREE.Mesh(gourdGeometry, gourdMaterial);
                    gourd.position.y = 0.35;
                    group.add(gourd);
                }
                
                return group;
            }
            
            addDynamicEffects(model) {
                // åŠ¨æ€æè´¨å˜åŒ–
                const colors = [0xFF5733, 0x33FF57, 0x3357FF, 0xFFFF33, 0xFF33FF];
                let colorIndex = 0;
                
                const materialInterval = setInterval(() => {
                    if (!model.parent) {
                        clearInterval(materialInterval);
                        return;
                    }
                    
                    model.traverse((child) => {
                        if (child.isMesh && child.material && child.material.color) {
                            colorIndex = (colorIndex + 1) % colors.length;
                            child.material.color.setHex(colors[colorIndex]);
                        }
                    });
                }, 3000);
                
                // åŠ¨æ€å…‰ç…§ï¼ˆå‘¼å¸æ•ˆæœï¼‰
                const lightAnimation = () => {
                    if (!model.parent) return;
                    
                    const time = Date.now() * 0.001;
                    const intensity = 0.5 + Math.sin(time) * 0.3;
                    
                    // å¦‚æœæœ‰å…‰æºç»„ä»¶ï¼Œè°ƒæ•´å¼ºåº¦
                    model.traverse((child) => {
                        if (child.isLight) {
                            child.intensity = intensity;
                        }
                    });
                    
                    requestAnimationFrame(lightAnimation);
                };
                lightAnimation();
            }
            
            toggleAudio() {
                if (this.audioManager) {
                    this.audioManager.togglePlayback();
                }
            }
            
            onSessionEnd() {
                xrSession = null;
                xrReferenceSpace = null;
                isWebXRActive = false;
                
                // åœæ­¢äºŒç»´ç æ£€æµ‹
                this.qrDetector.stopDetection();
                
                // é‡ç½®UI
                this.showStartUI();
                
                // æ¸…ç†åœºæ™¯
                if (activeModel) {
                    scene.remove(activeModel);
                    activeModel = null;
                }
                
                this.updateStatus('WebXRä¼šè¯å·²ç»“æŸ');
                this.updateDebugInfo('WebXRä¼šè¯å·²ç»“æŸ');
            }
            
            exitWebXR() {
                if (xrSession) {
                    xrSession.end();
                    xrSession = null;
                    xrReferenceSpace = null;
                    isWebXRActive = false;
                    
                    // åœæ­¢äºŒç»´ç æ£€æµ‹
                    this.qrDetector.stopDetection();
                    
                    // é‡ç½®UI
                    this.showStartUI();
                    
                    // æ¸…ç†åœºæ™¯
                    if (activeModel) {
                        scene.remove(activeModel);
                        activeModel = null;
                    }
                    
                    this.updateStatus('å·²é€€å‡ºWebXR');
                    this.updateDebugInfo('WebXRä¼šè¯å·²ç»“æŸ');
                }
            }
            
            render() {
                // åœ¨WebXRæ¨¡å¼ä¸‹è¿›è¡ŒäºŒç»´ç æ£€æµ‹
                if (isWebXRActive && this.qrDetector) {
                    this.qrDetector.detectInWebXR(renderer.domElement);
                }
                
                // æ¨¡å‹è‡ªåŠ¨æ—‹è½¬ï¼ˆå¦‚æœæ²¡æœ‰è¢«æ‰‹åŠ¨æ§åˆ¶ï¼‰
                if (activeModel && isWebXRActive) {
                    activeModel.rotation.y += 0.005;
                }
                
                renderer.render(scene, camera);
            }
            
            // UIæ›´æ–°æ–¹æ³•
            showStartUI() {
                document.getElementById('startContainer').style.display = 'block';
                document.getElementById('info').style.display = 'none';
                document.getElementById('controls').style.display = 'none';
                document.getElementById('debugInfo').style.display = 'none';
                document.getElementById('detectionOverlay').style.display = 'none';
            }
            
            showWebXRUI() {
                document.getElementById('startContainer').style.display = 'none';
                document.getElementById('info').style.display = 'block';
                document.getElementById('controls').style.display = 'block';
                document.getElementById('debugInfo').style.display = 'block';
                document.getElementById('detectionOverlay').style.display = 'block';
            }
            
            updateStatus(status) {
                document.getElementById('status').textContent = status;
                
                // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
                const indicator = document.querySelector('.status-indicator');
                indicator.className = 'status-indicator';
                
                if (status.includes('å‡†å¤‡')) {
                    indicator.classList.add('status-ready');
                } else if (status.includes('æ‰«æ') || status.includes('WebXRè¿è¡Œä¸­')) {
                    indicator.classList.add('status-scanning');
                } else if (status.includes('æ£€æµ‹åˆ°')) {
                    indicator.classList.add('status-detected');
                } else if (status.includes('é”™è¯¯') || status.includes('å¤±è´¥')) {
                    indicator.classList.add('status-error');
                }
            }
            
            updateQRResult(result) {
                document.getElementById('qrResult').textContent = result;
            }
            
            updateCurrentInstrument(instrument) {
                document.getElementById('currentInstrument').textContent = instrument;
            }
            
            updateAudioInfo(info) {
                document.getElementById('audioInfo').textContent = info;
            }
            
            updateDebugInfo(info) {
                const debugText = document.getElementById('debugText');
                const timestamp = new Date().toLocaleTimeString();
                debugText.innerHTML += `<div>${timestamp}: ${info}</div>`;
                debugText.scrollTop = debugText.scrollHeight;
            }
            
            enableAudioButton() {
                const button = document.getElementById('playButton');
                button.disabled = false;
                button.style.backgroundColor = '#007BFF';
            }
            
            showError(message) {
                document.getElementById('startContainer').innerHTML = 
                    `<h2>âŒ é”™è¯¯</h2><p>${message}</p>` +
                    '<button onclick="location.reload()" class="btn">é‡æ–°åŠ è½½</button>';
            }
        }
        
        // éŸ³é¢‘ç®¡ç†å™¨
        class AudioManager {
            constructor() {
                this.audioCache = new Map();
                this.currentAudio = null;
                this.isPlaying = false;
            }
            
            async preloadAudio(configs) {
                for (const [key, config] of Object.entries(configs)) {
                    try {
                        const audio = new Audio();
                        audio.src = config.audio;
                        audio.preload = 'auto';
                        
                        await new Promise((resolve) => {
                            audio.oncanplaythrough = resolve;
                            audio.onerror = resolve;
                            audio.load();
                        });
                        
                        this.audioCache.set(config.audio, audio);
                        console.log('éŸ³é¢‘é¢„åŠ è½½æˆåŠŸ:', config.audio);
                    } catch (error) {
                        console.error('éŸ³é¢‘é¢„åŠ è½½å¤±è´¥:', error);
                    }
                }
            }
            
            async switchAudio(audioPath) {
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio.currentTime = 0;
                }
                
                this.currentAudio = this.audioCache.get(audioPath);
                this.isPlaying = false;
                this.updatePlayButton();
            }
            
            togglePlayback() {
                if (!this.currentAudio) return;
                
                if (this.isPlaying) {
                    this.currentAudio.pause();
                    this.isPlaying = false;
                } else {
                    this.currentAudio.play().then(() => {
                        this.isPlaying = true;
                    }).catch((error) => {
                        console.error('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error);
                    });
                }
                this.updatePlayButton();
            }
            
            updatePlayButton() {
                const button = document.getElementById('playButton');
                if (button) {
                    button.textContent = this.isPlaying ? 'æš‚åœéŸ³ä¹' : 'æ’­æ”¾éŸ³ä¹';
                }
            }
        }
        
        // äºŒç»´ç æ£€æµ‹å™¨ - æ›´æ–°ä¸ºWebXRå…¼å®¹ç‰ˆæœ¬
        class QRDetector {
            constructor() {
                this.canvas = document.getElementById('qrCanvas');
                this.context = this.canvas.getContext('2d');
                this.isDetecting = false;
                this.onDetectionCallback = null;
                this.lastDetectionTime = 0;
                this.detectionCooldown = 2000;
                this.detectionAttempts = 0;
                this.maxAttempts = 100; // é™åˆ¶å°è¯•æ¬¡æ•°é˜²æ­¢æ€§èƒ½é—®é¢˜
            }
            
            startWebXRDetection(callback) {
                this.onDetectionCallback = callback;
                this.isDetecting = true;
                this.detectionAttempts = 0;
                
                // æ›´æ–°è°ƒè¯•ä¿¡æ¯
                if (window.app) {
                    window.app.updateDebugInfo('å¼€å§‹WebXRäºŒç»´ç æ£€æµ‹...');
                    window.app.updateDebugInfo('âš ï¸ æ³¨æ„ï¼šQuestå½“å‰ä¸æ”¯æŒåŸå§‹æ‘„åƒå¤´è®¿é—®');
                    window.app.updateDebugInfo('è¯·å°è¯•ä»¥ä¸‹æ›¿ä»£æ–¹æ¡ˆï¼š');
                    window.app.updateDebugInfo('1. ä½¿ç”¨è¾ƒå¤§çš„äºŒç»´ç ï¼ˆè‡³å°‘5cm x 5cmï¼‰');
                    window.app.updateDebugInfo('2. ç¡®ä¿äºŒç»´ç æ¸…æ™°å¯è§');
                    window.app.updateDebugInfo('3. å°è¯•ä¸åŒçš„å…‰ç…§æ¡ä»¶');
                }
                
                console.log('å¼€å§‹WebXRäºŒç»´ç æ£€æµ‹');
            }
            
            detectInWebXR(canvas) {
                if (!this.isDetecting || !this.onDetectionCallback) return;
                if (this.detectionAttempts >= this.maxAttempts) {
                    if (this.detectionAttempts === this.maxAttempts) {
                        console.log('å·²è¾¾åˆ°æœ€å¤§æ£€æµ‹å°è¯•æ¬¡æ•°ï¼Œå‡å°‘æ£€æµ‹é¢‘ç‡');
                        if (window.app) {
                            window.app.updateDebugInfo('å·²è¾¾åˆ°æœ€å¤§æ£€æµ‹å°è¯•æ¬¡æ•°ï¼Œå‡å°‘æ£€æµ‹é¢‘ç‡');
                        }
                    }
                    this.detectionAttempts++;
                    return; // å‡å°‘æ£€æµ‹é¢‘ç‡
                }
                
                // é˜²æŠ–å¤„ç†
                const now = Date.now();
                if (now - this.lastDetectionTime < 200) return; // é™ä½æ£€æµ‹é¢‘ç‡åˆ°æ¯200ms
                
                this.detectionAttempts++;
                
                try {
                    // è°ƒè¯•ï¼šå®šæœŸæŠ¥å‘Šæ£€æµ‹çŠ¶æ€
                    if (this.detectionAttempts % 50 === 0) {
                        console.log(`äºŒç»´ç æ£€æµ‹å°è¯• ${this.detectionAttempts}`);
                        if (window.app) {
                            window.app.updateDebugInfo(`äºŒç»´ç æ£€æµ‹å°è¯• ${this.detectionAttempts}/100`);
                        }
                    }
                    
                    // å°è¯•ä»WebXRæ¸²æŸ“å†…å®¹ä¸­æ£€æµ‹
                    this.canvas.width = canvas.width || 512;
                    this.canvas.height = canvas.height || 512;
                    
                    // æ¸…ç©ºcanvas
                    this.context.fillStyle = '#000000';
                    this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // å°è¯•ç»˜åˆ¶å½“å‰æ¸²æŸ“å†…å®¹
                    try {
                        this.context.drawImage(canvas, 0, 0, this.canvas.width, this.canvas.height);
                    } catch (drawError) {
                        // é¢„æœŸçš„é”™è¯¯ - WebXRçš„canvaså¯èƒ½æ— æ³•ç›´æ¥è¯»å–
                        if (this.detectionAttempts === 1) {
                            console.log('æ— æ³•ç›´æ¥è¯»å–WebXRç”»å¸ƒå†…å®¹ï¼ˆé¢„æœŸè¡Œä¸ºï¼‰');
                            if (window.app) {
                                window.app.updateDebugInfo('æ— æ³•ç›´æ¥è¯»å–WebXRç”»å¸ƒå†…å®¹');
                                window.app.updateDebugInfo('è¿™æ˜¯Questçš„é¢„æœŸé™åˆ¶');
                            }
                        }
                        return;
                    }
                    
                    // è·å–å›¾åƒæ•°æ®è¿›è¡Œæ£€æµ‹
                    const imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰å®é™…çš„å›¾åƒå†…å®¹
                    let hasContent = false;
                    for (let i = 0; i < imageData.data.length; i += 4) {
                        if (imageData.data[i] !== 0 || imageData.data[i+1] !== 0 || imageData.data[i+2] !== 0) {
                            hasContent = true;
                            break;
                        }
                    }
                    
                    if (!hasContent) {
                        if (this.detectionAttempts <= 5) {
                            console.log('ç”»å¸ƒå†…å®¹ä¸ºç©º');
                            if (window.app) {
                                window.app.updateDebugInfo('ç”»å¸ƒå†…å®¹ä¸ºç©º - æ— æ³•æ£€æµ‹äºŒç»´ç ');
                            }
                        }
                        return;
                    }
                    
                    // ä½¿ç”¨jsQRæ£€æµ‹äºŒç»´ç 
                    const code = jsQR(imageData.data, imageData.width, imageData.height, {
                        inversionAttempts: 'attemptBoth' // å°è¯•åè‰²æ£€æµ‹
                    });
                    
                    if (code && (now - this.lastDetectionTime > this.detectionCooldown)) {
                        console.log('WebXRä¸­æ£€æµ‹åˆ°äºŒç»´ç :', code.data);
                        if (window.app) {
                            window.app.updateDebugInfo('ğŸ‰ æˆåŠŸæ£€æµ‹åˆ°äºŒç»´ç : ' + code.data);
                        }
                        this.onDetectionCallback(code.data);
                        this.lastDetectionTime = now;
                        
                        // çŸ­æš‚åœæ­¢æ£€æµ‹ï¼Œé¿å…é‡å¤è§¦å‘
                        this.isDetecting = false;
                        setTimeout(() => {
                            this.isDetecting = true;
                            this.detectionAttempts = 0; // é‡ç½®è®¡æ•°
                        }, this.detectionCooldown);
                    }
                    
                } catch (error) {
                    if (this.detectionAttempts <= 3) {
                        console.error('WebXRäºŒç»´ç æ£€æµ‹é”™è¯¯:', error);
                        if (window.app) {
                            window.app.updateDebugInfo('æ£€æµ‹é”™è¯¯: ' + error.message);
                        }
                    }
                }
                
                this.lastDetectionTime = now;
            }
            
            stopDetection() {
                this.isDetecting = false;
                this.onDetectionCallback = null;
                this.detectionAttempts = 0;
                console.log('äºŒç»´ç æ£€æµ‹å·²åœæ­¢');
                if (window.app) {
                    window.app.updateDebugInfo('äºŒç»´ç æ£€æµ‹å·²åœæ­¢');
                }
            }
        }
        
        // å¯åŠ¨åº”ç”¨
        document.addEventListener('DOMContentLoaded', () => {
            console.log('å¯åŠ¨WebXRä¹å™¨åº”ç”¨...');
            console.log('ç¯å¢ƒæ£€æŸ¥:');
            console.log('- THREE.jsç‰ˆæœ¬:', THREE.REVISION);
            console.log('- jsQRå¯ç”¨:', typeof jsQR !== 'undefined');
            console.log('- WebXRå¯ç”¨:', !!navigator.xr);
            console.log('- GLTFLoaderå¯ç”¨:', typeof THREE.GLTFLoader !== 'undefined');
            
            try {
                new WebXRInstrumentApp();
            } catch (error) {
                console.error('åº”ç”¨å¯åŠ¨å¤±è´¥:', error);
                document.getElementById('startContainer').innerHTML = 
                    '<h2>âŒ å¯åŠ¨å¤±è´¥</h2><p>é”™è¯¯: ' + error.message + '</p>' +
                    '<button onclick="location.reload()" class="btn">é‡æ–°åŠ è½½</button>';
            }
        });
        
        // å…¨å±€é”™è¯¯å¤„ç†
        window.onerror = function(message, source, lineno, colno, error) {
            console.error("å…¨å±€é”™è¯¯:", {
                message, source, lineno, colno, error
            });
        };
    </script>
</body>
</html>